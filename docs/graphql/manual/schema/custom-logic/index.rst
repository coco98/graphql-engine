Adding custom logic - using schema stitching & custom resolvers
===============================================================

Hasura GraphQL engine provides instant GraphQL APIs over the tables and views of any Postgres database by
auto-generating the CRUD resolvers. However, sometimes you might have other custom business logic that needs to be
run along with the simple CRUD operations.

Here are a couple of common use cases:

- Fetching disparate data from other sources (e.g. from a weather API or another database)
- Customizing mutations (e.g. running validations before inserts)
- Overriding or extending the GraphQL types generated by GraphQL Engine (e.g. extend the ``author`` type in GraphQL Engine's schema with a related type called ``article`` that is sourced from another GraphQL schema or datasource)

The first use case can be handling by using just **Schema Stitching**, a process to simply merge multiple GraphQL schemas together into a combined schema (think of the merged schema as a union of top-level nodes from each of the subschemas).

.. image:: ../../../img/graphql/manual/schema/schema-stitching-v1-arch-diagram.png


For the other use cases, where you are effectively extending the behaviour of the GraphQL schema fields exposed by Hasura GraphQL engine, you need to proxy GraphQL Engine with a custom GraphQL Server that serves a modified version of the GraphQL Engine's schema that fits your needs and is supported by custom **resolvers** to handle the required behaviour.

.. image:: ../../../img/graphql/manual/schema/using-custom-resolvers-and-stitching.png

.. 
  To support the above example from the third use case (using the  `graphql-tools <https://github.com/apollographql/graphql-tools>`_ package): #. Define custom fields that extend existing types (``author`` and ``article``) with a relationship:
   .. code-block:: javascript
      const relationshipTypeDefs = `
        extend type Author {
          articles: [Article]
      }
        extend type Article {
          author: Author
        }
      `;
  #. Then you simply merge the three 3 schemas (for ``author``, ``article`` and the newly defined one above) and support the new fields by writing custom **resolvers** that handle the requisite delegation.

To summarize, the following are the different possible customizations possible to the Hasura GraphQL engine schema:

- Adding top-level fields to the Hasura GraphQL engine schema.
- Extending the GraphQL schema fields exposed by Hasura GraphQL engine.

Adding top-level fields to the Hasura GraphQL engine schema
-----------------------------------------------------------

This can be done using Hasura's :doc:`GraphQL schema stitching feature <schema-stitching>`.

Extending the fields exposed in the Hasura GraphQL engine schema
----------------------------------------------------------------

This can be done by writing custom resolvers for the extra fields.

.. toctree::
  :maxdepth: 2

  custom-resolvers
